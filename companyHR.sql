-- Yasir Hassan
-- Building a database called companyHR that has two tables - employees and mentorship.
-- The program demonstrates most of the concepts of MySQL

-- Create the database
CREATE DATABASE CompanyHR;

-- use the database
USE CompanyHR;

-- Create coEmployees tabe
-- this table name will be changed to employees
CREATE TABLE coEmployees(
	id INT PRIMARY KEY AUTO_INCREMENT,
	empName VARCHAR(225) NOT NULL,
	gender CHAR(1) NOT NULL,
	contactNum VARCHAR(225),
	age INT NOT NULL,
	dateGenerated TIMESTAMP NOT NULL DEFAULT NOW()
	);
    
-- Create mentorship table
CREATE TABLE mentorship(
	mentorId INT NOT NULL,
    menteeId INT NOT NULL,
    status VARCHAR(225) NOT NULL,
    project VARCHAR(225) NOT NULL,
    PRIMARY KEY(mentorId, menteeId, project),
    CONSTRAINT fk1 FOREIGN KEY(mentorId) REFERENCES coEmployees(id)
    ON DELETE CASCADE ON UPDATE RESTRICT,
    CONSTRAINT fk2 FOREIGN KEY(menteeId) REFERENCES coEmployees(id)
    ON DELETE CASCADE ON UPDATE RESTRICT,
	CONSTRAINT mmConstraint UNIQUE(mentorId, menteeId)
    );
    
-- Rename table coEmployees to employess
RENAME TABLE coEmployees TO employees;

-- modify employees table
-- Drop the age column 
-- Add another column called salary which is of FLOAT type and cannot be null. 
-- salary-column should come after the contact_num column 
-- a dd a new column called yearsInCompany 
-- which is of INT type and cannot be null. This column should come after the salary column	

ALTER TABLE employees
	DROP COLUMN age,
    ADD COLUMN salary FLOAT NOT NULL AFTER contactNum,
    ADD COLUMN yearsInCompany INT NOT NULL AFTER salary;
    
-- describe the table
DESCRIBE employees;

-- alter the mentorships table.
-- modify fk2 by changing ON UPDATE RESTRICT to ON UPDATE CASCADE 
-- drop the mm_constraint constraint
-- In order to modify the foreign key constraint, first drop the original foreign key

-- It is not allowed to drop and add a foreign key with 
-- the same name using a single ALTER statement
-- So, use two ALTERs
ALTER TABLE mentorship
	DROP FOREIGN KEY fk2;
    
-- using a new ALTER statement, add the foreign key back with the modified conditions. 
-- also drop the mm_constraint constraint:
ALTER TABLE mentorship 
	ADD CONSTRAINT fk2 FOREIGN KEY(menteeId) 
	REFERENCES employees(id) ON DELETE CASCADE ON UPDATE CASCADE, 
	DROP INDEX mmConstraint;
    
-- insert data or populate employees table
-- the primary key (id) is not in the INSERT statement
-- because it'll automatically be generated by the system
-- from constraint AUTO_INCREMENT
-- Same is for dateCreated which has a DEFAULT value
-- provided by the NOW() function.
INSERT INTO employees (empName, gender, contactNum, salary, yearsInCompany) 
VALUES ('James Lee', 'M', '516-514-6568', 3500, 11),
       ('Peter Pasternak', 'M', '845-644-7919', 6010, 10),
       ('Clara Couto', 'F', '845-641-5236', 3900, 8), 
       ('Walker Welch', 'M', NULL, 2500, 4),
       ('Li Xiao Ting', 'F', '646-218-7733', 5600, 4), 
       ('Joyce Jones', 'F', '523-172-2191', 8000, 3), 
       ('Jason Cerrone', 'M', '725-441-7172', 7980, 2),
       ('Prudence Phelps', 'F', '546-312-5112', 11000, 2), 
       ('Larry Zucker', 'M', '817-267-9799', 3500, 1), 
       ('Serena Parker', 'F', '621-211-7342', 12000, 1);

DESCRIBE employees;
SELECT * FROM employees;

-- inserting data into mentorship table:

INSERT INTO mentorship (mentorId, menteeId, status, project) 
VALUES (1, 2, 'Ongoing', 'SQF Limited'), 
(1, 3, 'Past', 'Wayne Fibre'), 
(2, 3, 'Ongoing', 'SQF Limited'), 
(3, 4, 'Ongoing', 'SQF Limited'), 
(6, 5, 'Past', 'Flynn Tech');

SELECT * FROM mentorship;

-- update employees table id 4

UPDATE employees 
SET id = 11 
WHERE id = 4;

-- from the above update, the id for Walker Welch
-- in the employees table is updated from 4 to 11. 
-- This update is cascaded to the mentorships table.

-- ----------------------------------------------
-- using subquery to get employees name
-- who work in SQF Limited project
SELECT empName 
FROM employees 
WHERE id IN (SELECT mentorId FROM mentorship WHERE project = 'SQF Limited');

-- group salary based on gender and 
-- find the max for each gender
-- only for those above 10000
SELECT gender, MAX(salary)
FROM employees
GROUP BY gender
HAVING MAX(salary) > 10000;

-- JOIN

SELECT employees.id, mentorship.mentorId, 
employees.empName AS 'Mentor', mentorship.project AS 'Project Name' 
FROM employees
JOIN mentorship 
ON employees.id = mentorship.mentorId;

-- selecting data using union
-- combining the results of 2 SELECTs
SELECT empName, salary 
FROM employees 
WHERE gender = 'M' 
UNION ALL 
SELECT empName, yearsInCompany 
FROM employees 
WHERE gender = 'F';
-- view
CREATE VIEW myView AS 
SELECT employees.id, mentorship.mentorId, 
employees.empName AS 'Mentor', 
mentorship.project AS 'Project Name' 
FROM mentorship 
JOIN employees 
ON
employees.id = mentorship.mentorId;

SELECT `Project Name` FROM myView;

-- Alter

ALTER VIEW myView AS 
SELECT employees.id, mentorship.mentorId,
employees.empName AS 'Mentor', 
mentorship.project AS 'Project' 
FROM mentorship
JOIN employees 
ON employees.id = mentorship.mentorId;

-- OUT Procedure
DELIMITER $$
CREATE PROCEDURE employeeNameGender(
	IN pEmpId INT, OUT pName VARCHAR(255), 
	OUT pGender CHAR(1))
BEGIN 
	SELECT empName, gender INTO pName, pGender 
	FROM employees WHERE id = pEmpId; 
END $$
DELIMITER ;

-- Call the OUT procedure
 CALL employeeNameGender(1, @vName, @vGender);
 
 -- select based on the value of @vGender
 SELECT * FROM employees
 WHERE gender = @vGender;
 
-- Stored Function
DELIMITER $$
CREATE FUNCTION calculateBonus(
	pSalary DOUBLE, pMultiple DOUBLE)
        RETURNS DOUBLE DETERMINISTIC 
BEGIN 
	DECLARE bonus DOUBLE(8, 2);
	SET bonus = pSalary * pMultiple; 
        RETURN bonus; 
END $$
DELIMITER ;

SELECT id, empName, salary, calculateBonus(
salary, 1.5) AS bonus FROM employees;
  
 







